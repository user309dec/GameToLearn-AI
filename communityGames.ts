/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
*/
/* tslint:disable */

// This data is structured to match the `CommunityGame` interface in App.tsx

export const initialCommunityGames = [
  {
    id: 'comm-cs-1',
    name: 'The Pythonic Quest',
    subject: 'Computer Science',
    type: 'rpg',
    imageUrl: 'https://youke1.picui.cn/s1/2025/09/21/68cf882e3b0e1.png',
    authorName: 'Ada Coder',
    ratings: { total: 19, count: 4 }, // avg 4.75
    averageRating: 4.75,
    data: {
      "title": "The Pythonic Quest: Escape the Labyrinth of Ignorance!",
      "scenes": [
        {
          "id": 1,
          "title": "The Whispering Scroll",
          "content": "<p>You find yourself in a dusty library. A single scroll lies open, glowing with a faint light. It describes the legend of the 'Variable,' a magical container that can hold any value.</p><p>The scroll reads: \"To begin your journey, you must first store your name in a variable called <code>character_name</code>.\"</p><svg viewBox=\"0 0 400 150\"><rect x=\"50\" y=\"30\" width=\"300\" height=\"90\" fill=\"#2a3459\" stroke=\"#73d8ff\" stroke-width=\"2\" rx=\"5\"/><text x=\"70\" y=\"70\" fill=\"#f0f0f0\">character_name</text><path d=\"M 230 75 L 250 75\" stroke=\"#73d8ff\" stroke-width=\"2\"/><text x=\"260\" y=\"70\" fill=\"#f0f0f0\"> = </text><rect x=\"280\" y=\"50\" width=\"100\" height=\"50\" fill=\"none\" stroke=\"#73d8ff\" stroke-dasharray=\"4\" rx=\"3\"/><text x=\"330\" y=\"80\" fill=\"#a0e8ff\" text-anchor=\"middle\">?</text><text x=\"200\" y=\"110\" fill=\"#f0f0f0\" text-anchor=\"middle\" font-size=\"16\">A place to store a value</text></svg>",
          "interaction": {
            "type": "multipleChoice",
            "question": "Which line of Python code correctly stores the name \"Elara\" in the variable `character_name`?",
            "options": [
              { "text": "character_name = \"Elara\"", "isCorrect": true, "feedback": "<p>Correct! The `=` is the assignment operator, and strings of text are enclosed in quotes.</p>" },
              { "text": "character_name: \"Elara\"", "isCorrect": false, "feedback": "<p>Not quite. The colon `:` is used for type hints, not for assigning values.</p>" },
              { "text": "\"Elara\" = character_name", "isCorrect": false, "feedback": "<p>Incorrect. In Python, the variable name must be on the left side of the `=` sign.</p>" }
            ]
          },
          "nextSceneId": 2
        },
        {
          "id": 2,
          "title": "The Guardian of the Gate",
          "content": "<p>A stone golem blocks your path. A riddle is etched on its chest: \"I have cities, but no houses. I have mountains, but no trees. I have water, but no fish. What am I?\"</p><p>To pass, you must present the correct answer, stored in a variable named <code>riddle_answer</code>, to the golem.</p><svg viewBox=\"0 0 400 180\"><path d=\"M 100 150 Q 150 50 200 150 Q 250 250 300 150\" stroke=\"#73d8ff\" fill=\"none\" stroke-width=\"2\"/><text x=\"110\" y=\"100\" fill=\"#f0f0f0\">\"A Map\"</text><path d=\"M 150 105 L 180 120\" stroke=\"#73d8ff\" stroke-width=\"2\"/><rect x=\"180\" y=\"110\" width=\"120\" height=\"50\" fill=\"#2a3459\" stroke=\"#73d8ff\" rx=\"5\"/><text x=\"240\" y=\"140\" fill=\"#f0f0f0\" text-anchor=\"middle\">riddle_answer</text><text x=\"200\" y=\"30\" fill=\"#a0e8ff\" font-size=\"20\">print(riddle_answer)</text></svg>",
          "interaction": {
            "type": "multipleChoice",
            "question": "What is the correct answer to the riddle?",
            "options": [
              { "text": "A globe", "isCorrect": false, "feedback": "<p>A good guess, but a globe has representations of all those things. The riddle points to something more abstract.</p>" },
              { "text": "A map", "isCorrect": true, "feedback": "<p>Exactly! A map has all these features represented symbolically. The golem rumbles and steps aside.</p>" },
              { "text": "A dream", "isCorrect": false, "feedback": "<p>An interesting thought, but the answer is more tangible and directly related to the riddle's components.</p>" }
            ]
          },
          "nextSceneId": null
        }
      ]
    }
  },
  {
    id: 'comm-math-1',
    name: 'Fractal Explorer',
    subject: 'Mathematics',
    type: 'webapp',
    imageUrl: 'https://youke1.picui.cn/s1/2025/09/21/68cf882f39c75.png',
    authorName: 'Mandy Brott',
    ratings: { total: 14, count: 3 }, // avg 4.66
    averageRating: 4.66,
    data: {
      spec: "This app will help a learner understand the concept of fractals, as exemplified by the Koch snowflake. The core idea is that fractals are patterns that repeat themselves at different scales.\n\nSPECIFICATIONS:\n\n1.  The app should start with a single equilateral triangle in the center of the screen.\n2.  The app should have a button labeled \"Iterate\" or similar.\n3.  When the \"Iterate\" button is pressed, the app should perform one iteration of the Koch snowflake construction. This involves adding a new equilateral triangle to the middle of each side of the existing shape (pointing outward). The new triangles should be 1/3 the size of the sides they are attached to. The app should smoothly animate this process, so that the snowflake appears to grow.\n4.  The app should display a counter showing the number of iterations performed. The counter should start at zero.\n5.  The app should have a button labeled \"Reset\" or similar. When the \"Reset\" button is pressed, the app should return to the initial state with only the single equilateral triangle and the iteration counter set to zero.\n6.  The app should display the formula for calculating the number of sides after each iteration: 3 * (4 to the power of n), where n is the iteration number.\n7. The app should display the (calculated) number of sides after each iteration.\n8. The app should include a \"zoom\" feature, such that the user may zoom in on any particular area of the image.  When the user zooms in, the fractal nature of the image (i.e., self-similarity at different scales) should be clearly visible.\n9. The app should allow the user to change the color of the snowflake, and the background. The app should include a few pre-selected color schemes for ease of use.\n\nProvide the code as a single, self-contained HTML document. All styles and scripts must be inline. In the result, encase the code between \"```\" and \"```\" for easy parsing.",
      code: "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Koch Snowflake Explorer</title>\n    <style>\n        body {\n            font-family: sans-serif;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            margin: 0;\n            padding: 10px;\n            background-color: #f0f0f0;\n            color: #333;\n        }\n        #canvasContainer {\n            position: relative; /* Needed for absolute positioning of overlay if added later */\n            border: 1px solid #ccc;\n            margin-bottom: 10px;\n            background-color: #fff; /* Default background */\n            cursor: grab;\n        }\n        #canvasContainer:active {\n             cursor: grabbing;\n        }\n        canvas {\n            display: block;\n        }\n        #controls {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 10px;\n            margin-bottom: 10px;\n            align-items: center;\n            justify-content: center;\n        }\n        button, select {\n            padding: 8px 15px;\n            font-size: 1em;\n            cursor: pointer;\n            border: 1px solid #ccc;\n            border-radius: 4px;\n            background-color: #e7e7e7;\n        }\n        button:hover, select:hover {\n            background-color: #ddd;\n        }\n        #info {\n            text-align: center;\n            margin-bottom: 10px;\n            font-size: 0.9em;\n            width: 100%;\n            max-width: 600px;\n        }\n        #info p {\n            margin: 5px 0;\n        }\n        .color-scheme-label {\n            margin-left: 15px;\n        }\n    </style>\n</head>\n<body>\n\n    <h1>Koch Snowflake Fractal Explorer</h1>\n\n    <div id=\"info\">\n        <p>Fractals are patterns that repeat themselves at different scales (self-similarity).</p>\n        <p>The Koch snowflake starts with an equilateral triangle. Each iteration adds a smaller triangle to the middle third of every side.</p>\n        <p>Use mouse wheel to zoom, click and drag to pan.</p>\n        <p>\n            Iterations: <span id=\"iterationCount\">0</span> |\n            Formula for sides: 3 * 4<sup>n</sup> |\n            Current Sides: <span id=\"sideCount\">3</span>\n        </p>\n    </div>\n\n    <div id=\"controls\">\n        <button id=\"iterateBtn\">Iterate</button>\n        <button id=\"resetBtn\">Reset</button>\n        <label for=\"colorSchemeSelect\" class=\"color-scheme-label\">Color Scheme:</label>\n        <select id=\"colorSchemeSelect\">\n            <option value=\"default\">Default (Blue on White)</option>\n            <option value=\"dark\">Dark Mode (Cyan on Black)</option>\n            <option value=\"forest\">Forest (Green on Beige)</option>\n            <option value=\"sunset\">Sunset (Orange on Dark Blue)</option>\n            <option value=\"mono\">Monochrome (White on Black)</option>\n        </select>\n    </div>\n\n    <div id=\"canvasContainer\">\n        <canvas id=\"kochCanvas\" width=\"600\" height=\"550\"></canvas>\n    </div>\n\n    <script>\n        const canvas = document.getElementById('kochCanvas');\n        const ctx = canvas.getContext('2d');\n        const iterateBtn = document.getElementById('iterateBtn');\n        const resetBtn = document.getElementById('resetBtn');\n        const iterationCountSpan = document.getElementById('iterationCount');\n        const sideCountSpan = document.getElementById('sideCount');\n        const colorSchemeSelect = document.getElementById('colorSchemeSelect');\n        const canvasContainer = document.getElementById('canvasContainer');\n\n        let iteration = 0;\n        let segments = [];\n        let snowflakeColor = '#007bff';\n        let backgroundColor = '#ffffff';\n        let zoomLevel = 1.0;\n        let offsetX = 0;\n        let offsetY = 0;\n        let isPanning = false;\n        let lastMouseX = 0;\n        let lastMouseY = 0;\n\n        const colorSchemes = {\n            default: { flake: '#007bff', bg: '#ffffff' },\n            dark:    { flake: '#00ffff', bg: '#000000' },\n            forest:  { flake: '#228B22', bg: '#F5F5DC' },\n            sunset:  { flake: '#FFA500', bg: '#00008B' },\n            mono:    { flake: '#ffffff', bg: '#000000' },\n        };\n\n        function getInitialTriangle(width, height) {\n            const side = Math.min(width, height) * 0.5;\n            const h = side * Math.sqrt(3) / 2;\n            const cx = width / 2;\n            const cy = height / 2 + h / 3;\n\n            const p1 = { x: cx, y: cy - 2 * h / 3 };\n            const p2 = { x: cx - side / 2, y: cy + h / 3 };\n            const p3 = { x: cx + side / 2, y: cy + h / 3 };\n\n            return [ [p1, p2], [p2, p3], [p3, p1] ];\n        }\n\n        function iterateKoch() {\n            if (iteration >= 8) { \n                 alert(\"Maximum iteration (8) reached.\");\n                 return;\n            }\n\n            const newSegments = [];\n            const sqrt3_2 = Math.sqrt(3) / 2;\n\n            for (const seg of segments) {\n                const p1 = seg[0];\n                const p2 = seg[1];\n\n                const dx = p2.x - p1.x;\n                const dy = p2.y - p1.y;\n\n                const pa = { x: p1.x + dx / 3, y: p1.y + dy / 3 };\n                const pb = { x: p1.x + 2 * dx / 3, y: p1.y + 2 * dy / 3 };\n\n                const midX = p1.x + dx / 2;\n                const midY = p1.y + dy / 2;\n\n                const vecX = -dy * sqrt3_2 / 3;\n                const vecY = dx * sqrt3_2 / 3;\n\n                const pc = { x: midX + vecX, y: midY + vecY };\n\n                newSegments.push([p1, pa]);\n                newSegments.push([pa, pc]);\n                newSegments.push([pc, pb]);\n                newSegments.push([pb, p2]);\n            }\n\n            segments = newSegments;\n            iteration++;\n            updateInfo();\n            drawSnowflake();\n        }\n\n        function drawSnowflake() {\n            ctx.fillStyle = backgroundColor;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            ctx.save();\n            ctx.translate(canvas.width / 2, canvas.height / 2);\n            ctx.scale(zoomLevel, zoomLevel);\n            ctx.translate(-canvas.width / 2 + offsetX, -canvas.height / 2 + offsetY);\n\n            if (segments.length > 0) {\n                ctx.beginPath();\n                ctx.moveTo(segments[0][0].x, segments[0][0].y);\n                for (const seg of segments) {\n                    ctx.lineTo(seg[1].x, seg[1].y);\n                }\n                ctx.fillStyle = snowflakeColor;\n                ctx.fill();\n            }\n            ctx.restore();\n        }\n\n        function updateInfo() {\n            iterationCountSpan.textContent = iteration;\n            const numSides = 3 * Math.pow(4, iteration);\n            sideCountSpan.textContent = numSides.toLocaleString();\n        }\n\n        function reset() {\n            iteration = 0;\n            zoomLevel = 1.0;\n            offsetX = 0;\n            offsetY = 0;\n            segments = getInitialTriangle(canvas.width, canvas.height);\n            updateInfo();\n            drawSnowflake();\n        }\n\n        function applyColorScheme(schemeName) {\n            const scheme = colorSchemes[schemeName];\n            if (scheme) {\n                snowflakeColor = scheme.flake;\n                backgroundColor = scheme.bg;\n                canvasContainer.style.backgroundColor = backgroundColor;\n                drawSnowflake();\n            }\n        }\n\n        iterateBtn.addEventListener('click', iterateKoch);\n        resetBtn.addEventListener('click', reset);\n        colorSchemeSelect.addEventListener('change', (e) => applyColorScheme(e.target.value));\n\n        canvas.addEventListener('wheel', (event) => {\n            event.preventDefault();\n            const rect = canvas.getBoundingClientRect();\n            const mouseX = event.clientX - rect.left;\n            const mouseY = event.clientY - rect.top;\n            const worldXBefore = (mouseX - canvas.width / 2) / zoomLevel + canvas.width / 2 - offsetX;\n            const worldYBefore = (mouseY - canvas.height / 2) / zoomLevel + canvas.height / 2 - offsetY;\n            const zoomFactor = event.deltaY < 0 ? 1.1 : 1 / 1.1;\n            zoomLevel *= zoomFactor;\n            const worldXAfter = (mouseX - canvas.width / 2) / zoomLevel + canvas.width / 2 - offsetX;\n            const worldYAfter = (mouseY - canvas.height / 2) / zoomLevel + canvas.height / 2 - offsetY;\n            offsetX += worldXAfter - worldXBefore;\n            offsetY += worldYAfter - worldYBefore;\n            drawSnowflake();\n        });\n\n        canvas.addEventListener('mousedown', (event) => {\n            if (event.button === 0) {\n                isPanning = true;\n                lastMouseX = event.clientX;\n                lastMouseY = event.clientY;\n                canvasContainer.style.cursor = 'grabbing';\n            }\n        });\n\n        canvas.addEventListener('mousemove', (event) => {\n            if (isPanning) {\n                const dx = event.clientX - lastMouseX;\n                const dy = event.clientY - lastMouseY;\n                offsetX += dx / zoomLevel;\n                offsetY += dy / zoomLevel;\n                lastMouseX = event.clientX;\n                lastMouseY = event.clientY;\n                drawSnowflake();\n            }\n        });\n\n        canvas.addEventListener('mouseup', (event) => {\n            if (event.button === 0) {\n                isPanning = false;\n                canvasContainer.style.cursor = 'grab';\n            }\n        });\n        canvas.addEventListener('mouseleave', () => {\n             if (isPanning) {\n                 isPanning = false;\n                 canvasContainer.style.cursor = 'grab';\n             }\n        });\n\n        applyColorScheme(colorSchemeSelect.value);\n        reset();\n    </script>\n</body>\n</html>"
    }
  },
  {
    id: 'comm-history-1',
    name: 'The Hieroglyph Cipher',
    subject: 'History',
    type: 'rpg',
    imageUrl: 'https://youke1.picui.cn/s1/2025/09/21/68cf882e9409c.png',
    authorName: 'Jean-François',
    ratings: { total: 24, count: 5 }, // avg 4.8
    averageRating: 4.8,
    data: {
      "title": "The Hieroglyph Cipher: Unlocking Ancient Egypt",
      "scenes": [
        {
          "id": 1,
          "title": "The Rosetta Stone",
          "content": "<p>You are an archaeologist in 1799. A soldier has just discovered a large, dark stone slab covered in writing. It appears to be the same text written in three different scripts!</p><p>You recognize one script as Ancient Greek. This could be the key to deciphering the other two, especially the mysterious Egyptian hieroglyphs.</p><svg viewBox=\"0 0 400 250\"><path d=\"M 50 20 H 350 A 100 100 0 0 1 350 220 H 50 A 100 100 0 0 1 50 20 Z\" fill=\"#333\" stroke=\"#555\" stroke-width=\"2\"/><text x=\"200\" y=\"60\" fill=\"#a0e8ff\" text-anchor=\"middle\" font-size=\"16\">Hieroglyphic</text><path d=\"M 70 80 H 330\" stroke=\"#73d8ff\" stroke-width=\"1\"/><text x=\"200\" y=\"120\" fill=\"#a0e8ff\" text-anchor=\"middle\" font-size=\"16\">Demotic</text><path d=\"M 70 140 H 330\" stroke=\"#73d8ff\" stroke-width=\"1\"/><text x=\"200\" y=\"180\" fill=\"#f0f0f0\" text-anchor=\"middle\" font-size=\"16\">Αρχαία Ελληνικά (Ancient Greek)</text></svg>",
          "interaction": {
            "type": "multipleChoice",
            "question": "Why was the Rosetta Stone so important for understanding hieroglyphs?",
            "options": [
              { "text": "It was a dictionary of Egyptian words.", "isCorrect": false, "feedback": "<p>Not quite. It wasn't a word-for-word dictionary, but something even more valuable.</p>" },
              { "text": "It was written by a famous pharaoh.", "isCorrect": false, "feedback": "<p>While the decree was from a pharaoh (Ptolemy V), its importance comes from its structure, not its author.</p>" },
              { "text": "It provided the same text in a known language (Greek).", "isCorrect": true, "feedback": "<p>Precisely! Because scholars could read the Greek portion, they could use it as a guide to decode the hieroglyphic version of the same message.</p>" }
            ]
          },
          "nextSceneId": 2
        },
        {
          "id": 2,
          "title": "The Cartouche Clue",
          "content": "<p>A scholar named Jean-François Champollion noticed that some hieroglyphs were enclosed in an oval shape called a 'cartouche'.</p><p>He theorized these cartouches contained something very important. By comparing them to the Greek text, he made a breakthrough.</p><svg viewBox=\"0 0 400 150\"><rect x=\"100\" y=\"50\" width=\"200\" height=\"50\" fill=\"none\" stroke=\"#73d8ff\" stroke-width=\"2\" rx=\"25\"/><text x=\"200\" y=\"80\" fill=\"#f0f0f0\" text-anchor=\"middle\">𓊪 𓏏 𓍯 𓃭 𓐝 𓇋 𓋴 (Ptolemy)</text><text x=\"200\" y=\"30\" fill=\"#f0f0f0\" text-anchor=\"middle\">What did the cartouches signify?</text></svg>",
          "interaction": {
            "type": "multipleChoice",
            "question": "What did the cartouches on the Rosetta Stone contain?",
            "options": [
              { "text": "The names of gods", "isCorrect": false, "feedback": "<p>While gods were hugely important, the key discovery within the cartouches was something else.</p>" },
              { "text": "The names of royalty (pharaohs)", "isCorrect": true, "feedback": "<p>Correct! Champollion correctly guessed the cartouches contained royal names like \"Ptolemy\" and \"Cleopatra.\" This allowed him to match the phonetic sounds of the hieroglyphs to known names, cracking the code!</p>" },
              { "text": "Magic spells", "isCorrect": false, "feedback": "<p>Hieroglyphs were used for magical texts, but the specific breakthrough with the cartouches related to names.</p>" }
            ]
          },
          "nextSceneId": null
        }
      ]
    }
  },
   {
    id: 'comm-art-1',
    name: 'Chord Companion',
    subject: 'Art',
    type: 'webapp',
    imageUrl: 'https://youke1.picui.cn/s1/2025/09/21/68cf882f57096.png',
    authorName: 'Wolfgang M.',
    ratings: { total: 8, count: 2 }, // avg 4.0
    averageRating: 4.0,
    data: {
        spec: "Build me an interactive web app to help a learner understand triads and their inversions.\n\nSPECIFICATIONS:\n1.  The app must feature an interactive keyboard. When a key is pressed, the corresponding note should sound.\n2.  The app must allow the user to select a root note (C, D, E, F, G, A, or B).  This root note should be displayed clearly. The root note should default to C.\n3. The app must allow the user to select a triad type (Major, Minor, Diminished, Augmented). The triad type should be displayed clearly. The triad type should default to Major.\n4. The app must allow the user to select an inversion (Root position, First Inversion, Second Inversion). The inversion should be displayed clearly. The inversion should default to Root Position.\n5. Based on the selected root, triad type, and inversion, the app must highlight the corresponding notes on the keyboard.  The notes should also sound.\n6. The app must display the formula for generating the triad in terms of intervals (e.g., for C Major, it should display 'Root: C, Third: Major Third, Fifth: Perfect Fifth'). For inversions, it should explicitly state which note is the lowest (e.g., 'Lowest note is Third').\n7.  The app must be responsive and work well on both desktop and mobile devices.\n\nProvide the code as a single, self-contained HTML document. All styles and scripts must be inline. In the result, encase the code between \"```\" and \"```\" for easy parsing.",
        code: "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Triads and Inversions</title>\n    <style>\n        * { box-sizing: border-box; margin: 0; padding: 0; }\n        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; background-color: #f0f0f0; color: #333; }\n        .app-container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); width: 100%; max-width: 800px; margin-bottom: 20px; }\n        h1 { text-align: center; margin-bottom: 20px; color: #2c3e50; }\n        .controls { display: flex; flex-wrap: wrap; justify-content: space-around; margin-bottom: 25px; gap: 15px; }\n        .control-group { display: flex; flex-direction: column; align-items: center; }\n        .control-group label { margin-bottom: 5px; font-weight: bold; color: #555; }\n        .control-group select { padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; min-width: 120px; background-color: #fff; cursor: pointer; }\n        .info-display { background-color: #e9ecef; padding: 15px; border-radius: 5px; margin-bottom: 25px; border: 1px solid #ced4da; }\n        .info-display p { margin-bottom: 8px; line-height: 1.5; }\n        .info-display strong { color: #343a40; }\n        .keyboard-container { width: 100%; margin: 0 auto; overflow-x: auto; padding-bottom: 10px; }\n        .keyboard { display: flex; position: relative; height: 180px; width: max-content; min-width: 100%; margin: 0 auto; border: 2px solid #555; border-radius: 5px; background-color: #333; }\n        .key { cursor: pointer; border: 1px solid #555; transition: background-color 0.1s ease; display: flex; align-items: flex-end; justify-content: center; padding-bottom: 5px; font-size: 0.8em; position: relative; }\n        .key.white { background-color: #ffffff; width: 50px; height: 100%; color: #333; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; z-index: 1; }\n        .key.black { background-color: #333333; width: 30px; height: 60%; color: #ffffff; position: absolute; top: 0; margin-left: -15px; z-index: 2; border-bottom-left-radius: 3px; border-bottom-right-radius: 3px; }\n        .key[data-note^=\"C#\"], .key[data-note^=\"Db\"] { margin-left: -15px; left: 50px; }\n        .key[data-note^=\"D#\"], .key[data-note^=\"Eb\"] { margin-left: -15px; left: 100px; }\n        .key[data-note^=\"F#\"], .key[data-note^=\"Gb\"] { margin-left: -15px; left: 200px; }\n        .key[data-note^=\"G#\"], .key[data-note^=\"Ab\"] { margin-left: -15px; left: 250px; }\n        .key[data-note^=\"A#\"], .key[data-note^=\"Bb\"] { margin-left: -15px; left: 300px; }\n        .key[data-note^=\"C#5\"], .key[data-note^=\"Db5\"] { left: calc(50px + 7 * 50px); }\n        .key[data-note^=\"D#5\"], .key[data-note^=\"Eb5\"] { left: calc(100px + 7 * 50px); }\n        .key[data-note^=\"F#5\"], .key[data-note^=\"Gb5\"] { left: calc(200px + 7 * 50px); }\n        .key[data-note^=\"G#5\"], .key[data-note^=\"Ab5\"] { left: calc(250px + 7 * 50px); }\n        .key[data-note^=\"A#5\"], .key[data-note^=\"Bb5\"] { left: calc(300px + 7 * 50px); }\n        .key:active, .key.pressed { background-color: #a0a0a0; }\n        .key.white:active, .key.white.pressed { background-color: #d0d0d0; }\n        .key.black:active, .key.black.pressed { background-color: #666666; }\n        .key.highlighted { background-color: #4a90e2; color: white; border: 2px solid #1a5dab; }\n        .key.black.highlighted { background-color: #3a7bc8; color: white; border: 1px solid #1a5dab; }\n        @media (max-width: 500px) {\n            body { padding: 10px; }\n            .app-container { padding: 15px; }\n            h1 { font-size: 1.5em; }\n            .controls { flex-direction: column; align-items: stretch; gap: 10px; }\n            .control-group select { width: 100%; }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"app-container\">\n        <h1>Triads and Inversions</h1>\n        <div class=\"controls\">\n            <div class=\"control-group\"><label for=\"root-select\">Root Note:</label><select id=\"root-select\"><option value=\"C\">C</option><option value=\"D\">D</option><option value=\"E\">E</option><option value=\"F\">F</option><option value=\"G\">G</option><option value=\"A\">A</option><option value=\"B\">B</option></select></div>\n            <div class=\"control-group\"><label for=\"triad-select\">Triad Type:</label><select id=\"triad-select\"><option value=\"Major\">Major</option><option value=\"Minor\">Minor</option><option value=\"Diminished\">Diminished</option><option value=\"Augmented\">Augmented</option></select></div>\n            <div class=\"control-group\"><label for=\"inversion-select\">Inversion:</label><select id=\"inversion-select\"><option value=\"Root Position\">Root Position</option><option value=\"First Inversion\">First Inversion</option><option value=\"Second Inversion\">Second Inversion</option></select></div>\n        </div>\n        <div class=\"info-display\">\n            <p><strong>Selection:</strong> <span id=\"selection-info\"></span></p>\n            <p><strong>Formula:</strong> <span id=\"formula-info\"></span></p>\n            <p><strong>Notes:</strong> <span id=\"notes-info\"></span></p>\n            <p id=\"lowest-note-info-container\" style=\"display: none;\"><strong>Lowest Note:</strong> <span id=\"lowest-note-info\"></span></p>\n        </div>\n        <div class=\"keyboard-container\"><div class=\"keyboard\" id=\"keyboard\"></div></div>\n    </div>\n    <script>\n        document.addEventListener('DOMContentLoaded', () => {\n            const keyboardDiv = document.getElementById('keyboard');\n            const rootSelect = document.getElementById('root-select');\n            const triadSelect = document.getElementById('triad-select');\n            const inversionSelect = document.getElementById('inversion-select');\n            const selectionInfo = document.getElementById('selection-info');\n            const formulaInfo = document.getElementById('formula-info');\n            const notesInfo = document.getElementById('notes-info');\n            const lowestNoteInfoContainer = document.getElementById('lowest-note-info-container');\n            const lowestNoteInfo = document.getElementById('lowest-note-info');\n            let audioContext;\n            const oscillators = {};\n\n            function initAudioContext() {\n                if (!audioContext) {\n                    try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) { console.error(\"Web Audio API not supported\"); }\n                }\n            }\n            function noteToFrequency(note) {\n                const freqs = { 'C4': 261.63, 'C#4': 277.18, 'Db4': 277.18, 'D4': 293.66, 'D#4': 311.13, 'Eb4': 311.13, 'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'Gb4': 369.99, 'G4': 392.00, 'G#4': 415.30, 'Ab4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'Bb4': 466.16, 'B4': 493.88, 'C5': 523.25, 'C#5': 554.37, 'Db5': 554.37, 'D5': 587.33, 'D#5': 622.25, 'Eb5': 622.25, 'E5': 659.25, 'F5': 698.46, 'F#5': 739.99, 'Gb5': 739.99, 'G5': 783.99, 'G#5': 830.61, 'Ab5': 830.61, 'A5': 880.00, 'A#5': 932.33, 'Bb5': 932.33, 'B5': 987.77, 'C6': 1046.50 };\n                return freqs[note];\n            }\n            function playNote(note, duration = 0.6) {\n                initAudioContext();\n                if (!audioContext) return;\n                const freq = noteToFrequency(note);\n                if (!freq) return;\n                const oscillator = audioContext.createOscillator();\n                const gainNode = audioContext.createGain();\n                oscillator.type = 'sine';\n                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);\n                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);\n                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration * 0.9);\n                oscillator.connect(gainNode);\n                gainNode.connect(audioContext.destination);\n                oscillator.start(audioContext.currentTime);\n                oscillator.stop(audioContext.currentTime + duration);\n            }\n            function playChord(notes) { initAudioContext(); notes.forEach(note => playNote(note, 1.0)); }\n\n            const notesSharp = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n            const notesFlat = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];\n            const shouldUseFlats = (root) => ['F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb'].includes(root) || root.includes('b');\n            function getNoteName(index, preferFlat = false) { return (preferFlat ? notesFlat : notesSharp)[index % 12]; }\n            function getNoteIndex(note) { let i = notesSharp.indexOf(note); return i === -1 ? notesFlat.indexOf(note) : i; }\n            function calculateTriadIntervals(type) {\n                switch (type) {\n                    case 'Minor': return { third: 3, fifth: 7, thirdName: \"Minor Third\", fifthName: \"Perfect Fifth\" };\n                    case 'Diminished': return { third: 3, fifth: 6, thirdName: \"Minor Third\", fifthName: \"Diminished Fifth\" };\n                    case 'Augmented': return { third: 4, fifth: 8, thirdName: \"Major Third\", fifthName: \"Augmented Fifth\" };\n                    default: return { third: 4, fifth: 7, thirdName: \"Major Third\", fifthName: \"Perfect Fifth\" };\n                }\n            }\n            function getTriadNotes(root, type, startOctave = 4) {\n                const rootIndex = getNoteIndex(root);\n                const intervals = calculateTriadIntervals(type);\n                const preferFlat = shouldUseFlats(root);\n                const rootName = getNoteName(rootIndex, preferFlat);\n                const thirdIndex = rootIndex + intervals.third;\n                const fifthIndex = rootIndex + intervals.fifth;\n                const thirdName = getNoteName(thirdIndex, preferFlat);\n                const fifthName = getNoteName(fifthIndex, preferFlat);\n                const thirdOctave = thirdIndex >= 12 ? startOctave + 1 : startOctave;\n                const fifthOctave = fifthIndex >= 12 ? startOctave + 1 : startOctave;\n                return [\n                    { name: rootName, octave: startOctave, note: `${rootName}${startOctave}`, role: \"Root\" },\n                    { name: thirdName, octave: thirdOctave, note: `${thirdName}${thirdOctave}`, role: \"Third\" },\n                    { name: fifthName, octave: fifthOctave, note: `${fifthName}${fifthOctave}`, role: \"Fifth\" }\n                ];\n            }\n            function applyInversion(notes, inversion) {\n                let invertedNotes = [...notes];\n                let lowestNoteRole = \"Root\";\n                if (inversion === 'First Inversion') {\n                    const root = notes[0];\n                    invertedNotes = [notes[1], notes[2], { ...root, octave: root.octave + 1, note: `${root.name}${root.octave + 1}` }];\n                    lowestNoteRole = \"Third\";\n                } else if (inversion === 'Second Inversion') {\n                    const root = notes[0], third = notes[1];\n                    invertedNotes = [notes[2], { ...root, octave: root.octave + 1, note: `${root.name}${root.octave + 1}` }, { ...third, octave: third.octave + 1, note: `${third.name}${third.octave + 1}` }];\n                    lowestNoteRole = \"Fifth\";\n                }\n                return { invertedNotes, lowestNoteRole };\n            }\n            function createKeyboard() {\n                keyboardDiv.innerHTML = '';\n                const keys = ['C4', 'C#4', 'D4', 'D#4', 'E4', 'F4', 'F#4', 'G4', 'G#4', 'A4', 'A#4', 'B4', 'C5', 'C#5', 'D5', 'D#5', 'E5', 'F5', 'F#5', 'G5', 'G#5', 'A5', 'A#5', 'B5', 'C6'];\n                const keyTypes = keys.map(k => k.includes('#') ? 'black' : 'white');\n                keys.forEach((note, i) => {\n                    const keyEl = document.createElement('div');\n                    keyEl.classList.add('key', keyTypes[i]);\n                    keyEl.dataset.note = note;\n                    keyEl.textContent = note.slice(0, -1);\n                    keyEl.addEventListener('mousedown', (e) => { e.preventDefault(); initAudioContext(); playNote(note); keyEl.classList.add('pressed'); });\n                    ['mouseup', 'mouseleave'].forEach(evt => keyEl.addEventListener(evt, () => keyEl.classList.remove('pressed')));\n                    keyboardDiv.appendChild(keyEl);\n                });\n            }\n            function updateDisplay() {\n                const root = rootSelect.value, type = triadSelect.value, inversion = inversionSelect.value;\n                selectionInfo.textContent = `${root} ${type}, ${inversion}`;\n                const rootPosNotes = getTriadNotes(root, type, 4);\n                const { invertedNotes, lowestNoteRole } = applyInversion(rootPosNotes, inversion);\n                const notesToHighlight = invertedNotes.map(n => n.note);\n                const intervals = calculateTriadIntervals(type);\n                formulaInfo.textContent = `Root: ${rootPosNotes[0].name}, Third: ${intervals.thirdName} (${rootPosNotes[1].name}), Fifth: ${intervals.fifthName} (${rootPosNotes[2].name})`;\n                notesInfo.textContent = notesToHighlight.join(', ');\n                if (inversion !== 'Root Position') {\n                    lowestNoteInfo.textContent = `${lowestNoteRole} (${invertedNotes[0].note})`;\n                    lowestNoteInfoContainer.style.display = 'block';\n                } else {\n                    lowestNoteInfoContainer.style.display = 'none';\n                }\n                highlightKeys(notesToHighlight);\n                playChord(notesToHighlight);\n            }\n            function highlightKeys(notes) {\n                document.querySelectorAll('.key.highlighted').forEach(k => k.classList.remove('highlighted'));\n                notes.forEach(note => {\n                    const sharpEq = note.replace('b', '#'), flatEq = note.replace('#', 'b');\n                    const keyEl = keyboardDiv.querySelector(`.key[data-note=\"${note}\"]`) || keyboardDiv.querySelector(`.key[data-note=\"${sharpEq}\"]`) || keyboardDiv.querySelector(`.key[data-note=\"${flatEq}\"]`);\n                    if (keyEl) keyEl.classList.add('highlighted');\n                });\n            }\n            [rootSelect, triadSelect, inversionSelect].forEach(el => el.addEventListener('change', updateDisplay));\n            createKeyboard();\n            updateDisplay();\n        });\n    </script>\n</body>\n</html>"
    }
  }
];
